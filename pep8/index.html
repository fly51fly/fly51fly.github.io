<!DOCTYPE html>
<html lang="en">
<head>

  <!-- Basic Page Needs
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta charset="utf-8">
  <title>PEP 8: Python代码风格指南</title>
  <meta name="description" content="">
  <meta name="author" content="">

  <!-- Mobile Specific Metas
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- JavaScripts! -->
  <script src="js/anchor.min.js"></script>
  <script src="js/table_of_contents.js"></script>

  <!-- FONT -->
  <link rel="stylesheet" type="text/css" href="/fonts/425974/1F0A82D67708082E5.css" />

  <!-- CSS  -->
  <link rel="stylesheet" href="css/normalize.css">
  <link rel="stylesheet" href="css/skeleton.css">
  <link rel="stylesheet" href="css/prism.css">
  <link rel="stylesheet" href="css/table_of_contents.css">

  <style>

    body {
      font-size: 1.8rem;
      text-rendering: optimizeLegibility;
    }

    /* Disable border around code blocks. */
    code.language-python {border: none;}

    /* Disable background for code blocks */
    pre.language-python {background: none;}

    /* Don't display line-feed charecters */
    .token.lf:before {content: '';}

    .token.comment {font-style: italic;}
    .token.punctuation {color: #585858;}
    .token.operator {color: #905947;}
    .token.number {color: #b60065;}
    .token.keyword {color: #007cb1;}
    .token.function {color: #c6425d;}


    /* Disable background for inline codeblocks. */
    code {
        background: none;
        border: none;
    }

    /* Operator Pro typeface for code examples. */
    code[class*="language-"], code {
        font-family: "Operator Mono A", "Operator Mono B";
        font-style: normal;
        font-weight: 400;
        font-size: 1.6rem;
    }

    pre.language-python {
        padding-top: 0px;

    }
    /* Make inline code examples stand out. */
    code {
        font-weight: 600;
        font-size: 1.6rem;
        padding: 0;
    }

    h1, h2, h3, h4 {
        font-weight: 400;
    }

    body {
        font-style: normal;
        font-weight: 400;
        font-family: "Ideal Sans A", "Ideal Sans B";
        font-variant-ligatures: discretionary-ligatures;

    }


    h1 {
        /* font-variant: small-caps; Problems with Safari. */
        font-family: "Operator A", "Operator B";
        font-size: 3.5rem;
    }

    h2 {
      font-family: "Operator A", "Operator B";
      font-style: italic;
      font-size: 2.5rem;
    }

    h3 {
        /*font-style: italic;*/
        font-family: "Operator A", "Operator B";
    }

/*    li p {
      padding-left: 1em;
    }*/


    ol {
      padding-left: 2em;
      padding-right: 1em;
    }

ol {
  margin: 0 0 1.5em;
  counter-reset: item;
}

ol > li {
  /*margin: 0;*/
  /*padding: 0 0 0 2em;*/
  text-indent: -1.6em;
  list-style-type: none;
  counter-increment: item;
}

ol > li:before {
  display: inline-block;
  width: 1em;
  padding-right: 0.5em;
  font-weight: bold;
  text-align: right;
  content: counter(item) ".";
}

.title {
  font-family: "Operator A", "Operator B";
  font-style: normal;
}

ul ol {
  font-size: 100%;
  margin-bottom: 2em;
}


ul > li {
  margin: 0;
  padding: 0 0 0 2em;
  /*text-indent: -1.5em;*/
  display: block;
  list-style-type: none;
  /*counter-increment: item;*/
}


/* Green is for go; Red is for stop! */
.yes + pre > code {
  border-left: 3px solid rgba(74, 182, 93, 1);
}
.no + pre > code {
  border-left: 3px solid rgb(244, 76, 78);
}

/* Firefox is the worst. */
@-moz-document url-prefix() {
    h1 {font-variant: normal;}
}


  </style>

</head>
<body>

  <!-- Primary Page Layout
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <div class="container">

    <div class="row" style="margin-top: 15%">
        <h1 class="title">PEP 8 — Python代码风格指南</h1>
        <div class="twelve columns">
        <p class="awesome">由 <a href="http://kennethreitz.org/bitcoin">Kenneth Reitz</a> 创建的优秀 <a href="https://www.python.org/dev/peps/pep-0008/"> PEP 8</a> 的(人性化)风格化呈现.</p>
        </div>
    </div>


    <div class="row">
      <div class="nine columns" style="margin-top: 10%">


<!-- PEP 8 BEGINS -->

<h1 id="introduction">介绍</h1>

<p>这篇文档，描述了Python主发行版中，标准库代码所遵循的规范。对于Python的C语言实现中采用的编码规范，请参考实现Python的C代码风格指南 <a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>。</p>

<p>本文档与 <a href="https://www.python.org/dev/peps/pep-0257/">PEP 257</a> (Docstring 约定) 均改编自Guido最早的Python风格指南文章，并添加了一些Barry的风格指南<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a>中的内容。</p>

<p>语言自身在不断改变，随着新规范出现、旧规范过时，代码风格也会随时间而改变。</p>

<p>很多项目都有自己的一套代码风格指南。如果和本指南发生冲突，应优先考虑项目相关指南。</p>


<h1 id="a-foolish-consistency-is-the-hobgoblin-of-little-minds">不要为一致性而一致性</h1>

<p>Guido的重要观点之一，就是代码被读的次数，比写的次数多得多。本指南旨在改善代码的可读性，让不同人写的、各式各样的Python代码，风格也能保持一致。就像<a href="https://www.python.org/dev/peps/pep-0020/">PEP 20</a>《Python之禅(Zen of Python)》里说的：“可读性至上(Readability counts)”。</p>

<p>风格指南讲的就是一致性。和风格指南保持一致很重要。在项目内部保持一致性，则更为重要。在同模块、函数内部保持一致性，则更更重要。</p>

<p>但，至关重要的是：知道什么情况下，应该违背一致性————风格指南并非处处适用。当存有疑虑时，请自行做出最佳决断。参考其他例子，做出最佳决定。有话就问。</p>

<p>尤其是：千万不要为了遵循本PEP，破坏向后兼容性！</p>

<p>有足够理由忽略本指南的另外几种情况：</p>

<div class="row">
<div class="one column">&nbsp;</div>
<div class="nine columns">

<ol style="list-style-type: decimal">

    <li>当应用风格指南，会让代码更难读，甚至让那些习惯读本PEP风格代码的人都觉得难懂时。</li>
    <li>需要和周围代码保持一致性，这些代码与指南风格相悖（可能是历史原因）————尽管这可能是个收拾别人烂摊子的好机会（真正的极限编程）。</li>
    <li>如果有问题的代码，时间早于引进指南的时间，就没必要修改它们。</li>
    <li>代码要和旧版Python保持兼容，而旧版Python不支持风格指南推荐的特性。</li>
</ol>

</div>

</div>



<h1 id="code-lay-out">代码布局</h1>


<h2 id="indentation">缩进</h2>


<p>每级缩进，用4个空格表示。</p>

<p>同一连续行包含的元素，要么用Python的隐式续行对齐，即垂直对齐于圆括号、方括号或花括号，要么用悬挂缩进(hanging indent)<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>对齐。悬挂缩进需要考虑两点：第一行不要包括参数，在续行中需要再增加一级缩进，以表明其与前一行是接续关系。</p>

<p class="yes"><span>Yes:</span></p>

<pre><code class="language-python"># 和开始分界符(左括号)对齐
foo = long_function_name(var_one, var_two,
                         var_three, var_four)

# 续行多四个空格(多缩进一级)以同其他代码区别
def long_function_name(
        var_one, var_two, var_three,
        var_four):
    print(var_one)

# 悬挂缩进要多缩进一级
foo = long_function_name(
    var_one, var_two,
    var_three, var_four)</code></pre>

<p class="no"><span>No:</span></p>

<pre><code class="language-python"># 垂直对齐时第一行不应该有参数
foo = long_function_name(var_one, var_two,
    var_three, var_four)

# 和后续行没有区分开，需要多缩进一级
def long_function_name(
    var_one, var_two, var_three,
    var_four):
    print(var_one)</code></pre>

<p>对续行来说，4空格的规则是可选项。</p>

<p>也就是说，这样也可以：</p>

<pre><code class="language-python"># 悬挂缩进可以不用4个空格表示缩进
foo = long_function_name(
  var_one, var_two,
  var_three, var_four)</code></pre>

<a id="if-statements"></a>
<p>如果<code>if</code>语句的条件太长、要分成多行，值得注意一点在于，双字符关键字(<code>if</code>等)加上一个空格、一个左括号，宽度正好等于4空格，自然就会造成续行的部分缩进也为4个空格，看上去明显和<code>if</code>条件语句中嵌套的其他缩进语句冲突了。本PEP中不强制要求如何区分续行的条件语句和<code>if</code>条件语句中嵌套的其他语句。以下几种方法都是可行的，且不仅限于这几种方法：</p>

<pre><code class="language-python"># 不另外加缩进
if (this_is_one_thing and
    that_is_another_thing):
    do_something()

# 增加一行注释，在编辑器高亮时能有所区分
if (this_is_one_thing and
    that_is_another_thing):
    # Since both conditions are true, we can frobnicate.
    do_something()

# 为条件语句的续行增加一级缩进
if (this_is_one_thing
        and that_is_another_thing):
    do_something()</code></pre>

<p>（另请参见下面关于应该在二元操作符之前还是之后断开的讨论）</p>

<p>续行多行结束右圆括号/方括号/花括号，可以单起一行写，和上一行首个非空白字符对齐，像这样：</p>

<pre><code class="language-python">my_list = [
    1, 2, 3,
    4, 5, 6,
    ]
result = some_function_that_takes_arguments(
    &#39;a&#39;, &#39;b&#39;, &#39;c&#39;,
    &#39;d&#39;, &#39;e&#39;, &#39;f&#39;,
    )</code></pre>
<p>也可以和多行最开始那一行第一个字符对齐：</p>
<pre><code class="language-python">my_list = [
    1, 2, 3,
    4, 5, 6,
]
result = some_function_that_takes_arguments(
    &#39;a&#39;, &#39;b&#39;, &#39;c&#39;,
    &#39;d&#39;, &#39;e&#39;, &#39;f&#39;,
)</code></pre>


<h2 id="tabs-or-spaces">Tab 还是 空格?</h2>

<p>建议用空格进行缩进。</p>

<p>只有在已有代码用的是tab缩进时，为了和之前代码保持一致，才使用tab。</p>

<p>Python 3 不允许tab和空格混合进行缩进。</p>

<p>Python 2 代码若有tab、空格混用的情况，应把tab全部转换为空格。</p>

<p>用命令行运行Python 2时，使用<code>-t</code>选项，混用tab和空格会出现非法使用的警告。当使用<code>-tt</code>选项时，警告会升级为错误。强烈推荐使用这些选项！</p>


<h2 id="maximum-line-length">单行最大长度</h2>

<p>把所有行长度限制在79个字符以内。</p>

<p>对于连续大段、结构限制又较少的文字（如文档字符串(docstring)或注释），单行长度应限制在72个字符以内。</p>

<p>限制编辑器的窗口宽度，让多个文件可同时打开并显示在屏幕上，在用代码评审(code review)工具时，可在两个相邻窗口显示两个版本的代码而不影响效果。</p>

<p>很多工具的默认自动换行功能，会破坏代码结构，使代码更难以理解。选择限制长度，是为了避免在窗口宽度设置为80的编辑器中换行，即使工具在换行时在最后一列放置了标记符号。一些网页版工具可能根本都不提供动态换行。</p>

<p>有些团队强烈希望采用更长的单行长度。如果代码仅由或主要由能就此问题达成一致的团队维护，可将行长度限制增加到99个字符，但注释和文档字符串仍遵循72字符换行。</p>

<p>Python标准库比较保守，要求将单行限制在79字符以内(文档字符串/注释限制在72个)。</p>

<p>一种推荐的长行换行方式，是用Python的圆括号、方括号和花括号进行隐式续行。长行可通过在括号内换行来分成多行。最好加上反斜杠以区别续行。</p>

<p>有时续行只能用反斜杠。例如，较长的、包含多个部分的<code>with</code>语句不能用隐式续行，只能用反斜杠表示换行：</p>

<pre><code class="language-python">with open(&#39;/path/to/some/file/you/want/to/read&#39;) as file_1, \
     open(&#39;/path/to/some/file/being/written&#39;, &#39;w&#39;) as file_2:
    file_2.write(file_1.read())</code></pre>

<p>（这里<code>with</code>语句的缩进可参照前面关于 <a href="#if-statements">多行if语句</a>缩进的讨论）</p>

<p>另一个类似的例子是<code>assert</code>语句。</p>

<p>请确保续行具有适当的缩进。</p>

<h2 id="break-before-or-after-binary-operator">二元操作符之前换行还是之后？</h2>

<p class="no">长期以来推荐风格是在二元操作符之后换行。但是这样会影响代码可读性，主要是两方面：一是运算符会分布在屏幕上的不同列上(参差不齐)，二是操作符会留在前一行、远离右边的操作数。读代码的时候眼睛要费点劲，才能看清谁被加了，谁又被减了：</p>

<pre><code class="language-python"># No: 操作符远离操作数
income = (gross_wages +
          taxable_interest +
          (dividends - qualified_dividends) -
          ira_deduction -
          student_loan_interest)
</code></pre>

<p>为了解决这个可读性问题，数学家和出版商遵循相反的惯例，Donald Knuth在他的<em>电脑与排版</em>系列中解释了传统的规则：</p>

<blockquote>“虽然段落中的公式总是在二元操作和关联之后换行，但显示公式时总是在二元操作之前中断”<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a>.</blockquote>

<p class="yes">遵循数学传统往往会产生更易读的代码:</p>

<pre><code class="language-python"># Yes: 匹配操作符和操作数更容易
income = (gross_wages
          + taxable_interest
          + (dividends - qualified_dividends)
          - ira_deduction
          - student_loan_interest)
</code></pre>

<p>Python代码中，在二元操作符之前或之后换行都可以，只要按约定在局部保持一致即可。对于新的代码，建议直接用Knuth风格。</p>

<h2 id="blank-lines">空行</h2>

<p>用2个空行来分隔最外层的函数(function)和类(class)定义。</p>

<p>用1个空行来分隔类中的方法(method)定义。</p>

<p>可以(尽量少)用额外的空行来分隔相关成组的函数。在一系列相关且仅占一行的函数间，空行可以省略(比如一组伪实现(dummy implementation))。</p>

<p>在函数内，(尽量少)用空行以使代码逻辑更清晰。</p>

<p>Python支持control-L(如:^L)换页符作为空格；许多工具将这些符号看做分页符，你可以用它们将文件相关部分分隔成单独的页。请注意，一些编辑器和网页版代码查看器可能不会将control-L识别为分页符，而是将其显示为其他符号。</p>


<h2 id="source-file-encoding">源文件编码</h2>

<p>Python核心发行版代码总是用UTF-8编码(Python 2中用ASCII)。</p>

<p>用ASCII编码(Python 2)或者UTF-8编码(Python 3)的文件不用添加编码声明。</p>

<p>在标准库中，只有用于测试目的、注释或文档字符串为提及作者名字不得不用非ASCII字符时，才能用非默认编码。否则，在字符串文字中包括非ASCII数据时，推荐使用<code>\x</code>, <code>\u</code>, <code>\U</code>, 或 <code>\N</code>等转义符号。</p>

<p>对于Python 3.0及其以后的版本中，标准库遵循以下原则(参见<a href="https://www.python.org/dev/peps/pep-3131">PEP 3131</a>)：Python标准库中所有标识符，只能用ASCII编码，能用英文单词的情况下*应尽量*使用英文单词(很多情况，缩写和技术术语并不是英文单词)。此外，字符串文字和注释应该只包括ASCII编码。只有两种情况属于例外：(a) 在测试用例中测试非ASCII编码特性 (b) 作者名字。作者名字不是由拉丁字母(latin-1, ISO/IEC 8859-1字符集)组成的，也<b>必须</b>提供该编码的音译名。</p>

<p>对于面向全球受众的开源项目，建议采用类似原则。</p>


<h2 id="imports">Imports</h2>

<ul>

<li><p>Import应该每行一个、单独写。</p>

<p class="yes"><span>Yes:</span></p>
<pre><code class="language-python">import os
import sys</code></pre>

<p class="no"><span>No:</span></p>
<pre><code class="language-python">import os, sys</code></pre>

<p>当然，这样写是可以的：</p>

<pre><code class="language-python">from subprocess import Popen, PIPE</code></pre></li>

<li><p>Imports总是位于代码文件的开头，在模块(module)注释和文档字符串(docstring)之后、模块全局变量(globals)和常量(constants)声明之前。</p>

<p>Imports按如下顺序分组写:</p>

<ol style="list-style-type: decimal">
<li>标准库imports</li>
<li>相关第三方imports</li>
<li>本地应用/库特定imports</li>
</ol>

<p>不同组imports之间用空行隔开。</p>

<li><p>推荐用绝对imports(absolute imports)，一方面更易读，另一方面，就算import系统配置有问题(比如包中路径以<code>sys.path</code>结尾)，也能表现得更好一些(至少会给出错误信息)：</p>

<pre><code class="language-python">import mypkg.sibling
from mypkg import sibling
from mypkg.sibling import example</code></pre>

<p>不过，除绝对imports之外，显式的相对imports，也是一种可以接受的替代方式。特别是包布局(package layouts)比较复杂时，用绝对imports会显得有些啰嗦：</p>

<pre><code class="language-python">from . import sibling
from .sibling import example</code></pre>

<p>标准库代码总是用绝对imports，并避免复杂的包布局。</p>

<p><b>绝对不用</b>隐式的相对imports，在Python 3中已经被去掉了。</p></li>

<li><p>从包含类的模块中import类，通常可以这样写：</p>

<pre><code class="language-python">from myclass import MyClass
from foo.bar.yourclass import YourClass</code></pre>

<p>如果拼写和本地命名发生冲突，直接import模块：</p>

<pre><code class="language-python">import myclass
import foo.bar.yourclass</code></pre>

<p>然后用<code>myclass.MyClass</code>和<code>foo.bar.yourclass.YourClass</code>引用类。</p></li>

<li><p>避免用通配符import(<code>from &lt;module&gt; import *</code>)，这样会造成当前命名空间搞不清哪些名字已用，给读者和自动化工具造成困扰。有一种情况可使用通配符import：将内部接口再发布成公用API的一部分(比如，用候选加速模块中的定义，覆盖纯Python实现的接口，预先无法知晓具体哪些定义将被覆盖)。</p>

<p>以这种方式再发布命名时，后面关于公共接口和内部接口的准则依然适用。</p></li>
</ul>

<h2 id="module-level-dunder-names">模块级双下划线命名</h2>

<p>模块级“双下滑线”(名字开头有两个下划线，结尾也有两个下划线)变量，如<code>__all__</code>, <code>__author__</code>, <code>__version__</code>等，应该放在模块文档字符串(docstring)之后、所有import语句之前，<b>除非是</b><code>from __future__</code> imports。Python要求，在模块中<code>from __future__</code> imports必须出现在除文档字符串(docstring)之外的所有代码之前。</p>

<pre><code class="language-python">"""This is the example module.

This module does stuff.
"""

from __future__ import barry_as_FLUFL

__all__ = ['a', 'b', 'c']
__version__ = '0.1'
__author__ = 'Cardinal Biggles'

import os
import sys
</code></pre>

<h1 id="string-quotes">字符串的引用</h1>


<p>在Python中，用单引号或双引号表示字符串都是一样的。但PEP不推荐两者混用。可以选择其中一种，坚持用下去。字符串包含单引号时，用双引号来表示字符串，反之亦然，可以避免用反斜杠转义，提高可读性。</p>

<p>三引号包围的字符串中，总是用双引号，以便和<a href="https://www.python.org/dev/peps/pep-0257/">PEP 257</a>的文档字符串(docstring)规则保持一致。</p>


<h1 id="whitespace-in-expressions-and-statements">表达式和语句中的空格</h1>


<h2 id="pet-peeves">招人烦</h2>


<p>下列情形中避免用多余空格：</p>

<ul>

<li><p>方括号、圆括号和花括号在括号内紧挨着括号的部分：</p>

<p class="yes"><span>Yes:</span></p>
<pre><code class="language-python">spam(ham[1], {eggs: 2})</code></pre>

<p class="no"><span>No:</span></p>
<pre><code class="language-python">spam( ham[ 1 ], { eggs: 2 } )</code></pre>

</li>

<li><p>结尾处的逗号和紧挨着的的右括号之间：</p>

<p class="yes"><span>Yes:</span></p>
<pre><code class="language-python">foo = (0,)</code></pre>

<p class="no"><span>No:</span></p>
<pre><code class="language-python">bar = (0, )</code></pre>

</li>

<li><p>紧接着是逗号、分号或冒号：</p>

<p class="yes"><span>Yes:</span></p>
<pre><code class="language-python">if x == 4: print x, y; x, y = y, x</code></pre>

<p class="no"><span>No:</span></p>
<pre><code class="language-python">if x == 4 : print x , y ; x , y = y , x</code></pre>

<li><p>不过，切片操作中的冒号和二元操作符一样，应该在其左右两边保留相同数量的空格(就像其他低优先级的运算符一样)。在扩展切片操作中，所有冒号的左右两边空格数都应该相等。不过也有例外，当切片操作参数被省略时，应忽略空格。</p>

<p class="yes"><span>Yes:</span></p>

<pre><code class="language-python">ham[1:9], ham[1:9:3], ham[:9:3], ham[1::3], ham[1:9:]
ham[lower:upper], ham[lower:upper:], ham[lower::step]
ham[lower+offset : upper+offset]
ham[: upper_fn(x) : step_fn(x)], ham[:: step_fn(x)]
ham[lower + offset : upper + offset]</code></pre>

<p class="no"><span>No:</span></p>

<pre><code class="language-python">ham[lower + offset:upper + offset]
ham[1: 9], ham[1 :9], ham[1:9 :3]
ham[lower : : upper]
ham[ : upper]</code></pre></li>

<li><p>函数调用时紧挨着传参数的左括号之前：</p>


<p class="yes"><span>Yes:</span></p>
<pre><code class="language-python">spam(1)</code></pre>

<p class="no"><span>No:</span></p>
<pre><code class="language-python">spam (1)</code></pre>


<li><p>索引和切片操作时紧挨着左括号之前：</p>


<p class="yes"><span>Yes:</span></p>
<pre><code class="language-python">dct[&#39;key&#39;] = lst[index]</code></pre>
<p class="no"><span>No:</span></p>
<pre><code class="language-python">dct [&#39;key&#39;] = lst [index]</code></pre></li>

<li><p>赋值(或其他)操作符周围，用多个空格和其他语句对齐：</p>

<p class="yes"><span>Yes:</span></p>

<pre><code class="language-python">x = 1
y = 2
long_variable = 3</code></pre>

<p class="no"><span>No:</span></p>

<pre><code class="language-python">x             = 1
y             = 2
long_variable = 3</code></pre></li>

</ul>


<h2 id="other-recommendations">其他建议</h2>


<ul>

<li>行末不要加空白————又看不到，只会让人困惑：例如，后跟空格和换行符的反斜杠，不算作行延续标记。一些编辑器不会保留它们，许多项目(如CPython本身)会用预提交钩子(pre-commit hooks)干掉它们。</li>
<p></p>
<li>二元操作符两边都加一个空格：赋值(<code>=</code>)，增量赋值(<code>+=</code>, <code>-=</code> 等)，比较(<code>==</code>, <code>&lt;</code>, <code>&gt;</code>, <code>!=</code>, <code>&lt;&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>in</code>, <code>not in</code>, <code>is</code>, <code>is not</code>)，布尔(<code>and</code>, <code>or</code>, <code>not</code>)。</li>
<p></p>
<li><p>如混合使用不同优先级的运算符，在优先级最低的操作符周围增加空白。可以自行判断；但，务必不要超过一个空格，务必保持二元操作符两侧空白一样多。</p>

<p class="yes"><span>Yes:</span></p>

<pre><code class="language-python">i = i + 1
submitted += 1
x = x*2 - 1
hypot2 = x*x + y*y
c = (a+b) * (a-b)</code></pre>

<p class="no"><span>No:</span></p>

<pre><code class="language-python">i=i+1
submitted +=1
x = x * 2 - 1
hypot2 = x * x + y * y
c = (a + b) * (a - b)</code></pre></li>

<li><p>函数注释应使用冒号的常规规则，在<code>-&gt;</code>箭头左右加上空格(如果要用的话)。(有关函数注释的更多信息，请参见下面的<a href="#function-annotations">函数注释</a>)</p>

<p class="yes"><span>Yes:</span></p>

<pre><code class="language-python">def munge(input: AnyStr): ...
def munge() -&gt; AnyStr: ...</code></pre>

<p class="no"><span>No:</span></p>

<pre><code class="language-python">def munge(input:AnyStr): ...
def munge()-&gt;PosInt: ...</code></pre></li>

<li><p>用<code>=</code>表示关键字参数、或表示<b>未注解(unannotated)</b>函数参数的默认值时，不要在其左右加空格。</p>

<p class="yes"><span>Yes:</span></p>

<pre><code class="language-python">def complex(real, imag=0.0):
    return magic(r=real, i=imag)</code></pre>

<p class="no"><span>No:</span></p>

<pre><code class="language-python">def complex(real, imag = 0.0):
    return magic(r = real, i = imag)</code></pre></li>
  
<li><p>函数注解和参数默认值组合使用时(参数既有函数注解，又有默认值），在<code>=</code>两边各用一个空格：</p>

<p class="yes"><span>Yes:</span></p>

<pre><code class="language-python">def munge(sep: AnyStr = None): ...
def munge(input: AnyStr, sep: AnyStr = None, limit=1000): ...</code></pre>

<p class="no"><span>No:</span></p>

<pre><code class="language-python">def munge(sep: AnyStr=None): ...
def munge(input: AnyStr, sep: AnyStr=None, limit = 1000): ...</code></pre></li>

<li><p>复合语句(将多行语句写成一行)一般不鼓励使用。</p>

<p class="yes"><span>Yes:</span></p>

<pre><code class="language-python">if foo == &#39;blah&#39;:
    do_blah_thing()
do_one()
do_two()
do_three()</code></pre>

<p class="no"><span>Rather not:</span></p>

<pre><code class="language-python">if foo == &#39;blah&#39;: do_blah_thing()
do_one(); do_two(); do_three()</code></pre></li>

<li><p>有时，将短小的if/for/while中的语句写在一行是可以的，但对于多子句语句永远不要写成一行。也不要对这种长长的行换行续行处理！</p>

<p class="no"><span>Rather not:</span></p>

<pre><code class="language-python">if foo == &#39;blah&#39;: do_blah_thing()
for x in lst: total += x
while t &lt; 10: t = delay()</code></pre>

<p class="no"><span>Definitely not:</span></p>

<pre><code class="language-python">if foo == &#39;blah&#39;: do_blah_thing()
else: do_non_blah_thing()

try: something()
finally: cleanup()

do_one(); do_two(); do_three(long, argument,
                             list, like, this)

if foo == &#39;blah&#39;: one(); two(); three()</code></pre></li>

</ul>


<h1 id="when-to-use-trailing-commas">何时在末尾加逗号</h1>


<p>末尾的逗号通常是可选的，只有在定义单元素元组(tuple)时是必需的(在Python 2中，具有<code>print</code>语句的语义)。为了更清楚，建议用括号(技术上是冗余的)括起来。</p>

<p class="yes"><span>Yes:</span></p>

<pre><code class="language-python">FILES = ('setup.cfg',)</code></pre>

<p>也还好, 但容易让人困惑：</p>

<pre><code class="language-python">FILES = 'setup.cfg',</code></pre>

<p>虽然最后这个逗号是冗余的，但使用版本控制系统时，对于将来有可能扩充值、参数或import项目的列表来说，还是有好处的。具体来说，就是将每个元素单独写一行，行尾加逗号，最后的右括号单独占一行。但是，元素都在同一行上，末尾加逗号作为结束分隔符，是无意义的(除了上面单元素元组的情况)。</p>

<p class="yes"><span>Yes:</span></p>

<pre><code class="language-python">FILES = [
    'setup.cfg',
    'tox.ini',
    ]
initialize(FILES,
           error=True,
           )</code></pre>

<p class="no"><span>No:</span></p>

<pre><code class="language-python">FILES = ['setup.cfg', 'tox.ini',]
initialize(FILES, error=True,)</code></pre>


<h1 id="comments">注释</h1>


<p>和代码相冲突的注释，还不如没有注释。代码有变动，一定优先保证注释也同步变动！</p>

<p>注释应该用完整句子。第一个单词首字母要大写，除非是以小写字母开头的标识符(标识符千万不要改变大小写！)。</p>

<p>块注释通常由一个或多个由完整句子组成的段落构成，每个句子以句号结尾。</p>

<p>如果是多句注释，除最后一句，在句尾的句号后应使用两个空格。</p>

<p>如用英语书写，请参考Strunk和White的《The Elements of Style》。</p>

<p>对于非英语国家的Python程序员：请用英语写下注释，除非你有120%的把握不会给不懂你语言的人看。</p>


<h2 id="block-comments">块注释</h2>


<p>块注释通常用于说明紧随其后的那些(或全部)代码，缩进级别和这些代码取齐。块注释的每一行，都以<code>#</code >和一个空格开始(除非文本是在注释内缩进对齐的)。</p>

<p>块注释里的段落，由只包含一个< code>#</code >的行隔开。</p>


<h2 id="inline-comments">行内注释</h2>


<p>慎用行内注释。</p>

<p>行内注释与语句写在同一行。行内注释和语句之间至少用两个空格隔开。注释以#和一个空格开始。</p>

<p>行内注释并不必要，实际上，如果说明的是显而易见的事，反而会分散注意力。</p>
<p class="no"><span>不要这样做:</span></p>

<pre><code class="language-python">x = x + 1                 # x 自增</code></pre>

<p class="yes"><span>但有时，这样做是有意义的:</span></p>

<pre><code class="language-python">x = x + 1                 # 边界补偿</code></pre>

<h2 id="documentation-strings">文档字符串</h2>

<p>要写出好的文档字符串(docstrings)，请参考<a href = " https://www . python . org/dev/peps/PEP-0257/">PEP 257</a>。</p>

<ul>

<li>应该为所有公共模块、函数、类和方法编写文档字符串。对非公共方法，文档字符串不是必需的，但应该有注释来描述该方法的功能。此注释应出现在<code>def</code>定义行之后。</li>
<p></p>
<li><p><a href="https://www.python.org/dev/peps/pep-0257/">PEP 257</a> 描述了好的文档字符串应遵循的规则。请注意，最重要的是，多行的文档字符串，应该用单独一行<code>&quot;&quot;&quot;</code>结尾，不能出现其他字符：</p>

<pre><code class="language-python">&quot;&quot;&quot;Return a foobang

Optional plotz says to frobnicate the bizbaz first.
&quot;&quot;&quot;</code></pre></li>

<li>单行的文档字符串，请将<code>&quot;&quot;&quot;</code>加在同一行末尾。</li>

</ul>

<h1 id="naming-conventions">命名约定</h1>


<p>Python库的命名约定有点混乱，所以我们永远都无法做到真正的一致————不过，这里给出目前推荐的命名标准。新的模块和包(包括第三方框架)应该按这些标准编写，但如果现有库有不同风格，还是首先要和原有风格保持内部一致性。</p>


<h2 id="overriding-principle">首要原则</h2>


<p>作为对用户可见的API公共部分的命名，首先应反映其用途，而不是其实现细节。</p>


<h2 id="descriptive-naming-styles">描述性：命名风格</h2>


<p>有好几种不同的命名风格。最好是不论其用途、看名字能直接看出用的是什么命名风格。</p>

<p>命名风格常用区分如下：</p>

<ul class="allowed">

<li><code>b</code> (单个小写字母)</li>
<li><code>B</code> (单个大写字母)</li>
<li><code>lowercase</code>(小写串)</li>
<li><code>lower_case_with_underscores</code>(带下划线的小写串)</li>
<li><code>UPPERCASE</code>(大写串)</li>
<li><code>UPPER_CASE_WITH_UNDERSCORES</code>(带下划线的大写串)</li>
<li><code>CapitalizedWords</code> (单词首字母大写串，也叫 CapWords, CamelCase<a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a>, StudlyCaps)</li>
<li><code>mixedCase</code> (与单词首字母大写不同，第一个单词首字母是小写！)</li>
<li><code>Capitalized_Words_With_Underscores</code> (难看！)</li>

</ul>

<div style="margin-left: -1.5em; padding-bottom: 1em;" class="row">

<div class="one column"><strong><small>注意:</small></strong></div>
<div class="eight columns"><p>采用CapWords风格时，缩写单词的所有字母都要大写。<code>HTTPServerError</code>就比<code>HttpServerError</code>要好。</p></div>


</div>

<p>还有一种风格，是用一个短且唯一的前缀，将相关的名字组合在一起。这在Python中用得不多，为完整起见还是提一下。例如, <code>os.stat()</code> 函数返回一个元组，其中元素按传统命名为<code>st_mode</code>, <code>st_size</code>, <code>st_mtime</code>等。(这样做，是为了强调与POSIX系统调用结构字段的一致性，让程序员感觉更熟悉)。</p>

<p>X11库所有公共函数都以X开头。在Python中，这种风格往往被认为没必要，因为属性名和方法名有对象名作为前缀，函数名有模块名作为前缀。</p>

<p>此外，还要区别下列以下划线开始或结尾的特殊形式(可以与其他大小写规则结合使用)：</p>

<ul>

<li><code>_single_leading_underscore</code>: (前置下划线)弱“内部专用”标志. 例如，<code>from M import *</code> 不导入名称以下划线开头的对象。</li>
<p></p>
<li><p><code>single_trailing_underscore_</code>: (后置下划线)按约定，可避免与Python关键字冲突, 例如：</p>

<pre><code class="language-python">Tkinter.Toplevel(master, class_=&#39;ClassName&#39;)</code></pre></li>

<li><code>__double_leading_underscore</code>: (前置双下划线)命名类属性时，触发命名修饰(在FooBar类内部, <code>__boo</code> 命名会被修饰成 <code>_FooBar__boo</code>; 如下).</li>
<p></p>

<li><code>__double_leading_and_trailing_underscore__</code>: (前后双置双下划线)存在于用户控制命名空间的“魔术”对象或属性(命名已存在，但往往需要用户覆写，以实现用户所需功能)。例如， <code>__init__</code>, <code>__import__</code> or <code>__file__</code>. 永远不要自己发明类似的名字；依文档描述使用。</li>

</ul>


<h2 id="prescriptive-naming-conventions">说明性：命名约定</h2>


<h3 id="names-to-avoid">要避免的名称</h3>


<p>永远不要用 ‘l’ (小写L), ‘O’ (大写O), 或 ‘I’ (大写I) 作为单字符变量名.</p>

<p>在某些字体中，这些字符与数字1、数字0几乎无法区分。想用“l”时，用“L”代替。</p>


<h3 id="ascii-compatibility">ASCII兼容性</h3>


<p>标准库中用的标识符，必须与ASCII兼容，如<a href="https://www.python.org/dev/peps/pep-3131">PEP 3131</a>的<a href="https://www.python.org/dev/peps/pep-3131/#policy-specification">policy</a>部分所述。</p>


<h3 id="package-and-module-names">包和模块的命名</h3>


<p>模块应该有简短的、全小写的名称。为提高可读性，可在模块命名中用下划线。Python包命名也要用全小写的短名称，但不鼓提倡用下划线。</p>

<p>用C或C++写的扩展模块，如果有附带的Python模块提供更高级(例如，更面向对象)的接口时，C/C++模块名以下划线开头(例如 <code>_socket</code>)。</p>


<h3 id="class-names">类的命名</h3>


<p>类名通常应采用CapWords风格。</p>

<p>在接口有文档说明，且主要用作可调用接口时，可使用函数的命名约定。</p>

<p>注意，内置命名(builtin names)有一个特殊约定：大多数内置命名是单个单词(或两个单词连在一起)，而CapWords约定仅用于异常命名和内置常量。</p>


<h3 id="type-variable-names">类型变量命名</h3>


<p>PEP 484中引入的类型变量的命名，通常采用简短的CapWords命名约定：<code>T</code>, <code>AnyStr</code>, <code>Num</code>. 建议添加后缀 <code>_co</code> 或 <code>_contra</code> 以声明协变(covariant)和逆变(contravariant)行为。</p>

  <pre class='language-python'><code class='language-python'>from typing import TypeVar

  VT_co = TypeVar('VT_co', covariant=True)
  KT_contra = TypeVar('KT_contra', contravariant=True)</code></pre>


<h3 id="exception-names">异常命名</h3>


<p>因为异常也是类，所以类命名约定在这里也适用。不过，应该给异常名加上“Error”后缀(如果异常实际上是个错误)。</p>


<h3 id="global-variable-names">全局变量的命名</h3>


<p>(假定这些变量只能在同一个模块中使用)这些约定与函数的约定大致相同。</p>

<p>被设计通过 <code>from M import *</code> 方式使用的模块，应该用 <code>__all__</code> 机制防止导出全局变量, 或者按老约定，在这些全局变量前加一个下划线(你可能想以此表明这些全局变量属于“模块非公开部分”)。</p>


<h3 id="function-and-variable-names">函数名和变量名</h3>


<p>函数名应该小写，必要时用下划线分隔单词，以提高可读性。</p>

<p>变量名遵循与函数名相同的约定。</p>

<p>mixedCase只在以它为代码风格的上下文中使用(例如threading.py)，以保持向后兼容性。</p>


<h3 id="function-and-method-arguments">函数和方法参数</h3>


<p>实例方法的第一个参数总是 <code>self</code> 。</p>

<p>类方法的第一个参数总是 <code>cls</code> 。</p>

<p>如果函数参数名与保留关键字冲突，最好加一个后置下划线，而不是用缩写或变体。<code>class_</code> 就比 <code>clss</code>要好。(或许更好的做法是用同义词来避免冲突)</p>


<h3 id="method-names-and-instance-variables">方法名和实例变量</h3>


<p>根据需要，使用函数命名规则：小写，单词间用下划线分隔，以提高可读性。</p>

<p>仅在非公开方法和实例变量名字前加一个下划线。</p>

<p>为避免命名与子类冲突，用前置的双下划线来触发Python的命名修饰机制。</p>

<p>Python类名的命名修饰规则：如果Foo类有个名为 <code>__a</code> 的属性, 不能用 <code>Foo.__a</code> 访问到它. (坚持的用户仍然可以通过调用 <code>Foo._Foo__a</code>访问到它) 一般来说，前置双下划线的命名方法，仅用于避免与设计为子类的类中的属性名冲突。</p>

<p><strong>注意:</strong> 关于 __names 的使用也有一些争议(如下)。</p>


<h3 id="constants">常量</h3>


<p>常量通常在模块级定义，全部大写并用下划线分隔单词。 例如 <code>MAX_OVERFLOW</code> 和 <code>TOTAL</code>.</p>


<h3 id="designing-for-inheritance">继承的设计</h3>


<p>总是想清楚，类方法和实例变量(统称为“属性”)应该是公开的还是非公开的。如果有疑问，就选择非公开；在之后，相比把公开属性变成非公开属性，把非公开属性变成公开属性要更容易些。</p>

<p>公开属性，是供那些和类设计无关的用户使用的属性，要确保其后续变更不会出现向后不兼容的问题。非公开属性，是那些你不打算让第三方使用的属性；无法确保非公开属性不被改动甚至删除。</p>

<p>在这里，我们不用“私有(private)”这个词，因为在Python中，没有什么属性是真正私有的(以节省往往不必要的额外工作)。</p>

<p>另一类属性，是那些属于“子类API”的属性(在其他语言也叫“受保护的(protected)”)。为扩展或修改类在某些方面的行为，我们会设计出一些继承自这些类的子类。设计这些子类时，要注意明确规划，哪些属性是公开的、哪些属性是子类API的一部分、哪些属性实际上仅供基类使用。</p>

<p>请把这几条放在心上，以下是Python风格的建议:</p>

<ul>

<li>公开属性名字前不要加下划线。</li>
<p></p>

<li><p>如果公开属性名与保留关键字冲突，在属性名结尾加一个下划线，比用缩写或变体更好。(不过，尽管有这样的规则，但‘cls’仍然是所有已知为类的变量或参数的首选拼写，尤其是类方法的第一个参数)</p>

<p><strong>注1</strong>: 关于类方法，参考之前的参数命名建议。</p></li>

<li><p>对于简单的公共数据属性，最好只公开属性名，而不要公开复杂的调用/设置方法。要是你发现哪个简单数据属性需要增加功能行为，记住，Python已经为将来的扩展提供了简单办法。用<code>property</code>注解，将功能实现隐藏在简单数据属性的访问语法背后。</p>

<p><strong>注1</strong>: <code>property</code>注解只对新风格的类有效</p>

<p><strong>注2</strong>: 尽量让功能行为无副作用，尽管像缓存之类的副作用也没什么大不了。</p>

<p><strong>注3</strong>: 对计算量大的操作，避免用<code>property</code>注解；属性符号会让调用者以为访问它运算量(相对)不大。</p></li>

<li><p>如果类会被子类继承，而有些属性你不打算让子类用，可以考虑在命名时加前置双下划线、而不是后置下划线。这样会触发Python的命名修饰算法，将类名修饰添加到属性名。这样做，还能避免在子类无意间包含同名属性而引发命名冲突。</p>

<p><strong>注1</strong>: 注意，命名修饰只是简单地把类名加到修饰名中，如果子类同时有相同的类名和属性名，依然会引发命名冲突。</p>

<p><strong>注2</strong>: 命名修饰可能会让调试和<code>__getattr__()</code>等的使用变得不那么方便。不过，命名修饰算法有详尽的文档，手动实现也很容易。</p>

<p><strong>注3</strong>: 不是所有人都喜欢命名修饰。在避免意外命名冲突，和满足高级调用者的潜在用法之间，要尽量寻求平衡。</p></li>

</ul>


<h2 id="public-and-internal-interfaces">公开接口和内部接口</h2>


<p>Any backwards compatibility guarantees apply only to public interfaces. Accordingly, it is important that users be able to clearly distinguish between public and internal interfaces.<br/>所有向后兼容性保证，都仅限于公开接口。因此，让用户能清楚区分公开接口和内部接口非常重要。</p>

<p>Documented interfaces are considered public, unless the documentation explicitly declares them to be provisional or internal interfaces exempt from the usual backwards compatibility guarantees. All undocumented interfaces should be assumed to be internal.<br/>写进文档里的接口，通常可理解为公开的，除非在文档里明确声明是临时的、或是不受向后兼容性保证约束的内部接口。所有没写进文档的接口，都被认为是内部接口。</p>

<p>To better support introspection, modules should explicitly declare the names in their public API using the <code>__all__</code> attribute. Setting <code>__all__</code> to an empty list indicates that the module has no public API.<br/>为了更好地支持内省(introspection)，模块应使用<code>__all__</code>属性，显式声明公开API有哪些命名。如<code>__all__</code>设为空列表，则表示该模块没有公开API。</p>

<p>Even with <code>__all__</code> set appropriately, internal interfaces (packages, modules, classes, functions, attributes or other names) should still be prefixed with a single leading underscore.<br/>即使设置了<code>__all__</code>，内部接口(包、模块、类、函数、属性及其他命名)仍应以一个下划线开头。</p>

<p>An interface is also considered internal if any containing namespace (package, module or class) is considered internal.<br/>如果任何包含某接口的命名空间(包、模块或类)被认为是内部的，那么该接口也被认为是内部接口。</p>

<p>Imported names should always be considered an implementation detail. Other modules must not rely on indirect access to such imported names unless they are an explicitly documented part of the containing module’s API, such as <code>os.path</code> or a package’s <code>__init__</code> module that exposes functionality from submodules.<br/><code>import</code>来的命名，应被视为实现细节。其他模块不得依赖对<code>import</code>命名的间接访问，除非文档明确说明它们是模块API的一部分，就像<code>os.path</code>、和从子模块开放内部功能的包的<code>__init__</code>模块一样。</p>


<h1 id="programming-recommendations">编程建议</h1>


<ul>

<li><p>Code should be written in a way that does not disadvantage other implementations of Python (PyPy, Jython, IronPython, Cython, Psyco, and such).<br/>代码的编写，不应对其他版本的Python实现(PyPy、Jython、IronPython、Cyt
    hon、Psyco等)不利。</p>

<p>For example, do not rely on CPython’s efficient implementation of in-place string concatenation for statements in the form <code>a += b</code> or <code>a = a + b</code>. This optimization is fragile even in CPython (it only works for some types) and isn’t present at all in implementations that don’t use refcounting. In performance sensitive parts of the library, the <code>''.join()</code> form should be used instead. This will ensure that concatenation occurs in linear time across various implementations.<br/>例如，不要为了利用CPython的就地字符串连接高效实现，而采用<code>a += b</code>或<code>a = a + b</code>这样的形式，即使在CPython中，这种优化也是脆弱的(只适用于某些类型)，更不用说在其他没用引用计数器的实现中，根本没有这种优化。对库中性能敏感的部分，可采用<code>''.join()</code>的形式。这样可以确保在各种实现中，字符串拼接都能在线性时间内完成。</p></li>

<li><p>Comparisons to singletons like None should always be done with <code>is</code> or <code>is not</code>, never the equality operators.<br/>类似 <code>None</code> 的单例(singleton)比较，应该总是用 <code>is</code> 或 <code>is not</code> ，而不是用<code>==</code>运算符。</p>

<p>Also, beware of writing <code>if x</code> when you really mean <code>if x is not None</code> – e.g. when testing whether a variable or argument that defaults to None was set to some other value. The other value might have a type (such as a container) that could be false in a boolean context!</p></li>

<li><p>Use <code>is not</code> operator rather than <code>not ... is</code>. While both expressions are functionally identical, the former is more readable and preferred.</p>

<p class="yes"><span>Yes:</span></p>

<pre><code class="language-python">if foo is not None:</code></pre>

<p class="no"><span>No:</span></p>

<pre><code class="language-python">if not foo is None:</code></pre></li>

<li><p>When implementing ordering operations with rich comparisons, it is best to implement all six operations (<code>__eq__</code>, <code>__ne__</code>, <code>__lt__</code>, <code>__le__</code>, <code>__gt__</code>, <code>__ge__</code>) rather than relying on other code to only exercise a particular comparison.</p>

<p>To minimize the effort involved, the <code>functools.total_ordering()</code> decorator provides a tool to generate missing comparison methods.</p>

<p><a href="https://www.python.org/dev/peps/pep-0207/">PEP 207</a> indicates that reflexivity rules <em>are</em> assumed by Python. Thus, the interpreter may swap <code>y &gt; x</code> with <code>x &lt; y</code>, <code>y &gt;= x</code> with <code>x &lt;= y</code>, and may swap the arguments of <code>x == y</code> and <code>x != y</code>. The <code>sort()</code> and <code>min()</code> operations are guaranteed to use the <code>&lt;</code> operator and the <code>max()</code> function uses the <code>&gt;</code> operator. However, it is best to implement all six operations so that confusion doesn’t arise in other contexts.</p></li>

<li><p>Always use a def statement instead of an assignment statement that binds a lambda expression directly to an identifier.</p>

<p class="yes"><span>Yes:</span></p>

<pre><code class="language-python">def f(x): return 2*x</code></pre>

<p class="no"><span>No:</span></p>

<pre><code class="language-python">f = lambda x: 2*x</code></pre>

<p>The first form means that the name of the resulting function object is specifically ‘f’ instead of the generic ‘&lt;lambda&gt;’. This is more useful for tracebacks and string representations in general. The use of the assignment statement eliminates the sole benefit a lambda expression can offer over an explicit def statement (i.e. that it can be embedded inside a larger expression)</p></li>

<li><p>Derive exceptions from <code>Exception</code> rather than <code>BaseException</code>. Direct inheritance from <code>BaseException</code> is reserved for exceptions where catching them is almost always the wrong thing to do.</p>

<p>Design exception hierarchies based on the distinctions that code <em>catching</em> the exceptions is likely to need, rather than the locations where the exceptions are raised. Aim to answer the question “What went wrong?” programmatically, rather than only stating that “A problem occurred” (see <a href="https://www.python.org/dev/peps/pep-3151/">PEP 3151</a> for an example of this lesson being learned for the builtin exception hierarchy)</p>

<p>Class naming conventions apply here, although you should add the suffix “Error” to your exception classes if the exception is an error. Non-error exceptions that are used for non-local flow control or other forms of signaling need no special suffix.</p></li>

<li><p>Use exception chaining appropriately. In Python 3, “raise X from Y” should be used to indicate explicit replacement without losing the original traceback.</p>

<p>When deliberately replacing an inner exception (using “raise X” in Python 2 or “raise X from None” in Python 3.3+), ensure that relevant details are transferred to the new exception (such as preserving the attribute name when converting KeyError to AttributeError, or embedding the text of the original exception in the new exception message).</p></li>

<li><p>When raising an exception in Python 2, use <code>raise ValueError('message')</code> instead of the older form <code>raise ValueError, 'message'</code>.</p>

<p>The latter form is not legal Python 3 syntax.</p>

<p>The paren-using form also means that when the exception arguments are long or include string formatting, you don’t need to use line continuation characters thanks to the containing parentheses.</p></li>

<li><p>When catching exceptions, mention specific exceptions whenever possible instead of using a bare <code>except:</code> clause.</p>

<pre><code class="language-python">try:
    import platform_specific_module
except ImportError:
    platform_specific_module = None</code></pre>

<p>A bare <code>except:</code> clause will catch SystemExit and KeyboardInterrupt exceptions, making it harder to interrupt a program with Control-C, and can disguise other problems. If you want to catch all exceptions that signal program errors, use <code>except Exception:</code> (bare except is equivalent to <code>except BaseException:</code>).</p>

<p>A good rule of thumb is to limit use of bare ‘except’ clauses to two cases:</p>

<ol style="list-style-type: decimal">

<li>If the exception handler will be printing out or logging the traceback; at least the user will be aware that an error has occurred.</li>

<li>If the code needs to do some cleanup work, but then lets the exception propagate upwards with <code>raise</code>. <code>try...finally</code> can be a better way to handle this case.</li>
</ol></li>

<li><p>When binding caught exceptions to a name, prefer the explicit name binding syntax added in Python 2.6:</p>

<pre><code class="language-python">try:
    process_data()
except Exception as exc:
    raise DataProcessingFailedError(str(exc))</code></pre>
<p>This is the only syntax supported in Python 3, and avoids the ambiguity problems associated with the older comma-based syntax.</p></li>

<li>When catching operating system errors, prefer the explicit exception hierarchy introduced in Python 3.3 over introspection of <code>errno</code> values.</li>

<p></p>
<li><p>Additionally, for all try/except clauses, limit the <code>try</code> clause to the absolute minimum amount of code necessary. Again, this avoids masking bugs.</p>

<p class="yes"><span>Yes:</span></p>

<pre><code class="language-python">try:
    value = collection[key]
except KeyError:
    return key_not_found(key)
else:
    return handle_value(value)</code></pre>

<p class="no"><span>No:</span></p>

<pre><code class="language-python">try:
    # Too broad!
    return handle_value(collection[key])
except KeyError:
    # Will also catch KeyError raised by handle_value()
    return key_not_found(key)</code></pre></li>

<li>When a resource is local to a particular section of code, use a <code>with</code> statement to ensure it is cleaned up promptly and reliably after use. A try/finally statement is also acceptable.</li>

<li><p>Context managers should be invoked through separate functions or methods whenever they do something other than acquire and release resources.</p>

<p class="yes"><span>Yes:</span></p>

<pre><code class="language-python">with conn.begin_transaction():
    do_stuff_in_transaction(conn)</code></pre>

<p class="no"><span>No:</span></p>

<pre><code class="language-python">with conn:
    do_stuff_in_transaction(conn)</code></pre>

<p>The latter example doesn’t provide any information to indicate that the <code>__enter__</code> and <code>__exit__</code> methods are doing something other than closing the connection after a transaction. Being explicit is important in this case.</p></li>

<li><p>Be consistent in return statements. Either all return statements in a function should return an expression, or none of them should. If any return statement returns an expression, any return statements where no value is returned should explicitly state this as <code>return None</code>, and an explicit return statement should be present at the end of the function (if reachable).</p>

<p class="yes"><span>Yes:</span></p>

<pre><code class="language-python">def foo(x):
    if x &gt;= 0:
        return math.sqrt(x)
    else:
        return None

def bar(x):
    if x &lt; 0:
        return None
    return math.sqrt(x)</code></pre>

<p class="no"><span>No:</span></p>

<pre><code class="language-python">def foo(x):
    if x &gt;= 0:
        return math.sqrt(x)

def bar(x):
    if x &lt; 0:
        return
    return math.sqrt(x)</code></pre></li>

<li><p>Use string methods instead of the string module.</p>

<p>String methods are always much faster and share the same API with unicode strings. Override this rule if backward compatibility with Pythons older than 2.0 is required.</p></li>

<li><p>Use <code>''.startswith()</code> and <code>''.endswith()</code> instead of string slicing to check for prefixes or suffixes.</p>

<p><code>startswith()</code> and <code>endswith()</code> are cleaner and less error prone.</p>


<p class="yes"><span>Yes:</span></p>
<pre><code class="language-python">if foo.startswith(&#39;bar&#39;):</code></pre>

<p class="no"><span>No:</span></p>
<pre><code class="language-python">if foo[:3] == &#39;bar&#39;:</code></pre>
</li>

<li><p>Object type comparisons should always use <code>isinstance()</code> instead of comparing types directly:</p>

<p class="yes"><span>Yes:</span></p>
<pre><code class="language-python">if isinstance(obj, int):</code></pre>

<p class="no"><span>No:</span></p>
<pre><code class="language-python">if type(obj) is type(1):</code></pre>

<p>When checking if an object is a string, keep in mind that it might be a unicode string too! In Python 2, str and unicode have a common base class, basestring, so you can do:</p>

<pre><code class="language-python">if isinstance(obj, basestring):</code></pre>

<p>Note that in Python 3, <code>unicode</code> and <code>basestring</code> no longer exist (there is only <code>str</code>) and a bytes object is no longer a kind of string (it is a sequence of integers instead)</p></li>

<li><p>For sequences, (strings, lists, tuples), use the fact that empty sequences are false:</p>

<p class="yes"><span>Yes:</span></p>
<pre><code class="language-python">if not seq:
if seq:</code></pre>

<p class="no"><span>No:</span></p>
<pre><code class="language-python">if len(seq):
if not len(seq):</code></pre>
</li>

<li>Don’t write string literals that rely on significant trailing whitespace. Such trailing whitespace is visually indistinguishable and some editors (or more recently, reindent.py) will trim them.</li>

<li><p>Don’t compare boolean values to True or False using <code>==</code>:</p>

<p class="yes"><span>Yes:</span></p>
<pre><code class="language-python">if greeting:</code></pre>

<p class="no"><span>No:</span></p>
<pre><code class="language-python">if greeting == True:</code></pre>

<p class="no">Worse:</p>
<pre><code class="language-python">if greeting is True:</code></pre></li>

</ul>


<h2 id="function-annotations">Function Annotations</h2>


<p>With the acceptance of <a href="https://www.python.org/dev/peps/pep-0484/">PEP 484</a>, the style rules for function annotations are changing.</p>

<ul>

<li>In order to be forward compatible, function annotations in Python 3 code should preferably use <a href="https://www.python.org/dev/peps/pep-0484/">PEP 484</a> syntax. (There are some formatting recommendations for annotations in the previous section.)</li>
<p></p>
<li>The experimentation with annotation styles that was recommended previously in this PEP is no longer encouraged.</li>
<p></p>
<li>However, outside the stdlib, experiments within the rules of <a href="https://www.python.org/dev/peps/pep-0484/">PEP 484</a> are now encouraged. For example, marking up a large third party library or application with <a href="https://www.python.org/dev/peps/pep-0484/">PEP 484</a> style type annotations, reviewing how easy it was to add those annotations, and observing whether their presence increases code understandability.</li>
<p></p>
<li>The Python standard library should be conservative in adopting such annotations, but their use is allowed for new code and for big refactorings.</li>
<p></p>
<li><p>For code that wants to make a different use of function annotations it is recommended to put a comment of the form:</p>

<pre><code class="language-python"># type: ignore</code></pre>

<p>near the top of the file; this tells type checker to ignore all annotations. (More fine-grained ways of disabling complaints from type checkers can be found in <a href="https://www.python.org/dev/peps/pep-0484/">PEP 484</a>.)</p></li>

<li>Like linters, type checkers are optional, separate tools. Python interpreters by default should not issue any messages due to type checking and should not alter their behavior based on annotations.</li>
<p></p>
<li>Users who don’t want to use type checkers are free to ignore them. However, it is expected that users of third party library packages may want to run type checkers over those packages. For this purpose <a href="https://www.python.org/dev/peps/pep-0484/">PEP 484</a> recommends the use of stub files: .pyi files that are read by the type checker in preference of the corresponding .py files. Stub files can be distributed with a library, or separately (with the library author’s permission) through the typeshed repo <a href="#fn6" class="footnoteRef" id="fnref6"><sup>6</sup></a>.</li>
<p></p>
<li><p>For code that needs to be backwards compatible, type annotations can be added in the form of comments. See the relevant section of PEP 484 <a href="#fn7" class="footnoteRef" id="fnref7"><sup>7</sup></a>.</p></li>

</ul>


<h2 id="variable-annotations">Variable Annotations</h2>


<p><a href="https://www.python.org/dev/peps/pep-0526">PEP 526</a> introduced variable annotations. The style recommendations for them are similar to those on function annotations described above:</p>
<ul>
<li>Annotations for module level variables, class and instance variables, and local variables should have a single space after the colon.</li>
<p></p>
<li>There should be no space before the colon.</li>
<p></p>
<li>If an assignment has a right hand side, then the equality sign should have exactly one space on both sides.</li>
<p></p>
<li>
<p class="yes"><span>Yes:</span></p>
<pre><code class="language-python">code: int

class Point:
    coords: Tuple[int, int]
    label: str = '&lt;unknown&gt;'</code></pre>
</li>
<li>
<p class="no"><span>No:</span></p>
<pre><code class="language-python">code:int  # No space after colon
code : int  # Space before colon

class Test:
    result: int=0  # No spaces around equality sign</code></pre>
</li>
<li>Although the <a href="https://www.python.org/dev/peps/pep-0526">PEP 526</a> is accepted for Python 3.6, the variable annotation syntax is the preferred syntax for stub files on all versions of Python (see <a href="https://www.python.org/dev/peps/pep-0484">PEP 484</a> for details).</li>
</ul>

<hr />

<h3><small>Footnotes</small></h3>

<div class="footnotes">

<ol>
<li id="fn1"><p><a href="https://www.python.org/dev/peps/pep-0007/">PEP 7</a>, Style Guide for C Code, van Rossum<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Barry’s GNU Mailman style guide <a href="http://barry.warsaw.us/software/STYLEGUIDE.txt" class="uri">http://barry.warsaw.us/software/STYLEGUIDE.txt</a><a href="#fnref2">↩</a></p></li>
<li id="fn3"><p><em>Hanging indentation</em> is a type-setting style where all the lines in a paragraph are indented except the first line. In the context of Python, the term is used to describe a style where the opening parenthesis of a parenthesized statement is the last non-whitespace character of the line, with subsequent lines being indented until the closing parenthesis.<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>Donald Knuth's <em>The TeXBook</em>, pages 195 and 196.<a href="#fnref4">↩</a></p></li>
<li id="fn5"><p><a href="http://www.wikipedia.com/wiki/CamelCase" class="uri">http://www.wikipedia.com/wiki/CamelCase</a><a href="#fnref5">↩</a></p></li>
<li id="fn6"><p>Typeshed repo <a href="https://github.com/python/typeshed" class="uri">https://github.com/python/typeshed</a><a href="#fnref6">↩</a></p></li>
<li id="fn7"><p>Suggested syntax for Python 2.7 and straddling code <a href="https://www.python.org/dev/peps/pep-0484/#suggested-syntax-for-python-2-7-and-straddling-code" class="uri">https://www.python.org/dev/peps/pep-0484/#suggested-syntax-for-python-2-7-and-straddling-code</a><a href="#fnref7">↩</a></p></li>
</ol>
</div>



<h4 id="section"></h4>
<h3 id="copyright"><small>Copyright</small></h3>
<p>This document has been placed in the public domain.</p>




<!-- PEP 8 ENDS -->

      </div>
    </div>
  </div>

<!-- End Document
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->

  <!-- GitHub Banner. -->
  <a href="https://github.com/fly51fly/fly51fly.github.io/tree/master/pep8"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/38ef81f8aca64bb9a64448d0d70f1308ef5341ab/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6461726b626c75655f3132313632312e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png"></a>


  <!-- JavaScripts! -->

  <!-- Syntax Hilighting. -->
  <script src="js/prism.js"></script>

  <!-- Anchors.js -->
  <script>anchors.add()</script>

</body>
</html>
